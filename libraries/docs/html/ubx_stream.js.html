<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ubx_stream.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ubx_stream.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>let stream =
{
    // Generic methods
    create: ffi('int mjsApiStreamCreate(char*, void (*)(int, int, int, void*, userdata), userdata)'),
    connect: ffi('int mjsApiStreamConnect(int)'),
    disconnect: ffi('int mjsApiStreamDisconnect(int)'),
    destroy: ffi('int mjsApiStreamDestroy(int)'),
    status: ffi('int mjsApiStreamStatus(int)'),
    send: ffi('int mjsApiStreamSend(int, int, void*)'),
    getUrl: ffi('int mjsApiStreamGetUrl(int, char*, char*)'),
    // Stream specific methods
    getBtFrameSize: ffi('int mjsApiStreamGetBtFrameSize(int)'), // Only for SPS
    asynchRead: ffi('int mjsApiStreamAsynchRead(int, int)'), // Only for I2C

    getUartId: ffi('int mjsApiStreamGetUartId(void)'),
    getAtId: ffi('int mjsApiStreamGetAtId(void)'),
    getDebugId: ffi('int mjsApiStreamGetDebugId(void)'),

    // Callback events
    CALLBACK_EVENT_CONNECTION: 0,
    CALLBACK_EVENT_DATA_AVAILABLE: 1,
    CALLBACK_EVENT_SEND_COMPLETE: 2,

    // Connection event ids
    CONNECTION_EVT_CONNECTING: 0,
    CONNECTION_EVT_CONNECTED: 1,
    CONNECTION_EVT_DISCONNECTED: 2,
    CONNECTION_EVT_ERROR: 6,

    // Link status callback results
    LINK_RESULT_UNKNOWN: 0,
    LINK_RESULT_DISCONNECTED: 1,
    LINK_RESULT_CONNECTED: 2,

    // Error codes for all API functions
    RESULT_OK: 0,
    RESULT_OK_CONNECTING: -1,
    RESULT_OK_DISCONNECTING: -2,
    RESULT_NO_MORE_STREAM_IDS: -3,
    RESULT_INVALID_ID: -4,
    RESULT_BUSY: -5,
    RESULT_FAILED: -6,
    RESULT_COULD_NOT_ALLOCATE: -7,
};

/**
 * Create a stream. Returns stream ID on success and status when failing.
 * @param {int} url - URL depending on the type of connection
 * &lt;br>&amp;nbsp;&amp;nbsp; Client - Remote URLs
 * &lt;br>&amp;nbsp;&amp;nbsp; If the script acts as a client the URL contains the remote address
 * &lt;br>&amp;nbsp;&amp;nbsp; and can start to setup connection any time with a call to StreamConnect().
 * &lt;br>&amp;nbsp;&amp;nbsp; Note: A remote can be both a wired connection (e.g. a connected sensor)
 * &lt;br>&amp;nbsp;&amp;nbsp; or an SPS (serial port service over BLE) connection over the air.
 * &lt;br>&amp;nbsp;&amp;nbsp;
 * &lt;br>&amp;nbsp;&amp;nbsp; Server - Protocol identifier
 * &lt;br>&amp;nbsp;&amp;nbsp; If the script act as a server and accepts incoming connections, the URL
 * &lt;br>&amp;nbsp;&amp;nbsp; identifies the given protocol. StreamConnect() can only be called after
 * &lt;br>&amp;nbsp;&amp;nbsp; a remote entity tries to connect to this server (as indicated by the
 * &lt;br>&amp;nbsp;&amp;nbsp; CONNECTION_EVT_CONNECTING event).
 * &lt;br>&amp;nbsp;&amp;nbsp;
 * &lt;br>&amp;nbsp;&amp;nbsp; Client URL format
 * &lt;br>&amp;nbsp;&amp;nbsp; The URL has the following format for SPS:
 * &lt;br>&amp;nbsp;&amp;nbsp; "sps://address" for example "sps://78A5042F4ADEp"
 * &lt;br>&amp;nbsp;&amp;nbsp; address - Bluetooth address
 * &lt;br>&amp;nbsp;&amp;nbsp;
 * &lt;br>&amp;nbsp;&amp;nbsp; The URL has the following format/options for I2C:
 * &lt;br>&amp;nbsp;&amp;nbsp; "i2c://port:address/?query_string"
 * &lt;br>&amp;nbsp;&amp;nbsp; For example: "i2c://secondary1:72/?freq=100&amp;read_freq=5000&amp;nr_bytes=2&amp;no_stop=false&amp;init_command=0100&amp;read_command=00&amp;timeout=500"
 * &lt;br>&amp;nbsp;&amp;nbsp; port - The physical port pin pair of the module for I2C data and clock.
 * &lt;br>&amp;nbsp;&amp;nbsp; address - I2C address. Note that this is the 7-bit address. If 8-bit address is used it might need to be converted.
 * &lt;br>&amp;nbsp;&amp;nbsp; query_string - can define the following:
 * &lt;br>&amp;nbsp;&amp;nbsp; read_freq - Value of read frequency in ms. Optional. Default is 0. i.e. no reading in intervals is done.
 * &lt;br>&amp;nbsp;&amp;nbsp; nr_bytes - number of bytes to periodically read. Optional. Default is 0.
 * &lt;br>&amp;nbsp;&amp;nbsp; no_stop - don't send stop bit, true or false. Optional. Default value is false.
 * &lt;br>&amp;nbsp;&amp;nbsp; freq - I2C bus speed, 100 or 400 kHz. Optional. Default value is 100 kHz.
 * &lt;br>&amp;nbsp;&amp;nbsp; init_command - I2C command to run once. Optional. Default is no init command.
 * &lt;br>&amp;nbsp;&amp;nbsp; read_command - I2C command for reading periodically. Must specify nr_bytes if this is used. Optional. Default is no read command.
 * &lt;br>&amp;nbsp;&amp;nbsp; timeout - Timeout in ms for I2C read and write operations. Optional. Default is 1000 ms.
 * &lt;br>&amp;nbsp;&amp;nbsp;
 * &lt;br>&amp;nbsp;&amp;nbsp; Server URL format
 * &lt;br>&amp;nbsp;&amp;nbsp; protocol://protocol, currently only sps://sps supported
 * @param {streamCallback} callback - Callback for all stream related events.
 * @param {any} userdata - Identifier when callback is triggered. Can be any type.
 * @return {int} streamId. Will be zero or positive on success and negative status when failing
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_NO_MORE_STREAM_IDS Max number of streams is already reached.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_FAILED The stream could not be created e.g. bad URL.
 */
let StreamCreate = function (url, callback, userdata) {
    return stream.create(url, callback, userdata);
};

/**
 * Connect a stream. For a client (see StreamCreate()) this may be called at any time and can be immediate
 * (for a local connection) or delayed when synchronization with a remote is required.&lt;br>
 * For a server this shall only be called after receiving CONNECTION_EVT_CONNECTING.&lt;br>
 *
 * Connect may be called multiple times and should in that case return the current status.
 * 
 * @param {int} id - Stream id.
 * @return {int} Result
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_OK_CONNECTING The stream is in a negotiation sequence and will be connected once callback with stream.LINK_RESULT_CONNECTED is generated.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID Operation failed because invalid id was provided.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_FAILED The stream failed to connect.
 */
let StreamConnect = function (id) {
    return stream.connect(id);
};

/**
* Stream callback triggered on all stream related events.
* @callback streamCallback
* @param {int} id - Stream id
* @param {int} eventType - Type of callback event, see CALLBACK_EVENT_* above
* @param {int} param - Event specific integer parameter:
* &lt;br>&amp;nbsp;&amp;nbsp; CALLBACK_EVENT_CONNECTION:
* &lt;br>&amp;nbsp;&amp;nbsp; - Connection event id, see CONNECTION_EVT_*
* &lt;br>&amp;nbsp;&amp;nbsp; CALLBACK_EVENT_DATA_AVAILABLE:
* &lt;br>&amp;nbsp;&amp;nbsp; - Data length
* &lt;br>&amp;nbsp;&amp;nbsp; CALLBACK_EVENT_SEND_COMPLETE:
* &lt;br>&amp;nbsp;&amp;nbsp; - Not applicable
* @param {int} data - Event specific data parameter:
* &lt;br>&amp;nbsp;&amp;nbsp; CALLBACK_EVENT_CONNECTION
* &lt;br>&amp;nbsp;&amp;nbsp; - Not applicable
* &lt;br>&amp;nbsp;&amp;nbsp; CALLBACK_EVENT_DATA_AVAILABLE
* &lt;br>&amp;nbsp;&amp;nbsp; - Data
* &lt;br>&amp;nbsp;&amp;nbsp; CALLBACK_EVENT_SEND_COMPLETE
* &lt;br>&amp;nbsp;&amp;nbsp; - Not applicable
* @param {any} userdata Userdata from the original call
* @return {void}
*/
let StreamCallback = function (id, eventType, param, data, userdata) { };

/** 
 * Disconnect a stream.
 *
 * @param {int} id - Stream id.
 *
 * @return {int} Result
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_OK The stream is disconnected and can safely be destroyed.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_OK_DISCONNECTING The stream is closing and may yet have outstanding resources.
 *                StreamCallback stream.CALLBACK_EVENT_CONNECTION with stream.LINK_RESULT_DISCONNECTED is generated once fully disconnected.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID Operation failed because invalid id was provided.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_FAILED The stream failed to disconnect.
 */
let StreamDisconnect = function (id) {
    return stream.disconnect(id);
};

/** 
 * Destroy a stream and release all allocated resources.
 *
 * @param {int} id - Stream id.
 *
 * @return {int} Result
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_OK The stream is destroyed.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID Operation failed because invalid id was provided.
 */
let StreamDestroy = function (id) {
    return stream.destroy(id);
};

/** 
 * Fetch the current connection status of the stream.
 *
 * @param {int} id - Stream id.
 *
 * @return {int} Result
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID Operation failed because invalid id was provided.
 * &lt;br>&amp;nbsp;&amp;nbsp; Valid connection status of stream, see stream.LINK_RESULT_*
 */
let StreamStatus = function (id) {
    return stream.status(id);
};

/**
 * Send a data packet to a stream. 
 * When the packet has been fully accepted, a callback with stream.CALLBACK_EVENT_SEND_COMPLETE will be generated.
 *
 * @param {int} id - Stream id.
 * @param {int} length - Data packet size.
 * @param {any} data - Data packet to be written.
 *
 * @return {int} Result
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_OK The data packet was accepted and will be sent.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_BUSY The stream is currently busy and can't currently process any more data.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID Operation failed because invalid id was provided.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_COULD_NOT_ALLOCATE Could not allocate data for the stream.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_FAILED The stream is not in a state that can accept data.
 */
let StreamSend = function(id, length, data) {
    return stream.send(id, length, data);
};

/**
 * Get stream local and remote URL.
 *
 * @param {int} id - Stream id.
 *
 * @return Result - Object with result and URLs
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_OK The operation succeeded.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID Operation failed because invalid id was provided.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_FAILED The stream is not in a state where the URL can be retrieved.
*/
let StreamGetUrl = function (id) {
    let remoteUrl = "                                ";
    let localUrl =  "                                ";
    let result = stream.getUrl(id, remoteUrl, localUrl);
    let remoteUrl2 = remoteUrl.slice(1, remoteUrl.at(0)+1);
    let localUrl2 = localUrl.slice(1, localUrl.at(0)+1);
    return {
        result: result,
        remoteUrl: remoteUrl2,
        localUrl: localUrl2,
    }
};

/**
 * Get BT frame size. Only applicable for the SPS stream.
 *
 * @param {int} id - Stream id.
 *
 * @return {int} Result - Frame size on success(> 0) or error when failing.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID Operation failed because invalid id was provided.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_FAILED The operation is not supported or in wrong state.
*/
let StreamGetBtFrameSize = function(id) {
    return stream.getBtFrameSize(id);
};

/**
 * Do an asynchronous read. Only applicable for the I2C stream.
 * The read data will be provided by stream.CALLBACK_EVENT_DATA_AVAILABLE in the callback.
 *
 * @param {int} id - Stream id.
 * @param {int} outdataLength - Number of bytes to read out.
 * @return {int} Result
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_OK The operation succeeded.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID Operation failed because invalid id was provided.
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_FAILED The operation is not supported or in wrong state.
*/
let StreamAsynchRead = function(id, outdataLength) {
    return stream.asynchRead(id, outdataLength);
};

/**
 * Returns the id of the UART stream created by default in non-deployed mode.
 * Use to manipulate the default UART stream.
 * @Note Command will always return stream.RESULT_INVALID_ID in deployed mode
 *
 * @return {int} id or error code
 * &lt;br>&amp;nbsp;&amp;nbsp; 0 or higher: Valid id
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID: No UART stream created from outside script
 */
let StreamGetUartId = function() {
    return stream.getUartId();
};

/**
 * Returns the id of the AT stream created by default in non-deployed mode.
 * Use to manipulate the default AT stream.
 * @Note Command will always return stream.RESULT_INVALID_ID in deployed mode
 *
 * @return {int} id or error code
 * &lt;br>&amp;nbsp;&amp;nbsp; 0 or higher: Valid id
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID: No AT stream created from outside script
 */
let StreamGetAtId = function() {
    return stream.getAtId();
};

/**
 * Returns the id of the debug stream created by default in non-deployed mode.
 * Use to manipulate the default debug stream.
 * @Note Command will always return stream.RESULT_INVALID_ID in deployed mode
 *
 * @return {int} id or error code
 * &lt;br>&amp;nbsp;&amp;nbsp; 0 or higher: Valid id
 * &lt;br>&amp;nbsp;&amp;nbsp; stream.RESULT_INVALID_ID: No debug stream created from outside script
 */
let StreamGetDebugId = function() {
    return stream.getDebugId();
};

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#BleGapDiscover">BleGapDiscover</a></li><li><a href="global.html#BleGapDiscoverCallback">BleGapDiscoverCallback</a></li><li><a href="global.html#BleGapDiscoverComplCallback">BleGapDiscoverComplCallback</a></li><li><a href="global.html#BleGapGetLocalAddr">BleGapGetLocalAddr</a></li><li><a href="global.html#BleGapSetAdvData">BleGapSetAdvData</a></li><li><a href="global.html#BleGapSetDiscoverCallback">BleGapSetDiscoverCallback</a></li><li><a href="global.html#BleSecEraseAllPeersRequest">BleSecEraseAllPeersRequest</a></li><li><a href="global.html#BleSecSetPairingMode">BleSecSetPairingMode</a></li><li><a href="global.html#GatewayBind">GatewayBind</a></li><li><a href="global.html#GatewayRelease">GatewayRelease</a></li><li><a href="global.html#GattsCharacteristicCreate">GattsCharacteristicCreate</a></li><li><a href="global.html#GattsDescriptorCreate">GattsDescriptorCreate</a></li><li><a href="global.html#GattsReadResp">GattsReadResp</a></li><li><a href="global.html#GattsSend">GattsSend</a></li><li><a href="global.html#GattsServiceCreate">GattsServiceCreate</a></li><li><a href="global.html#GattsSetEventCallback">GattsSetEventCallback</a></li><li><a href="global.html#GattsWrite">GattsWrite</a></li><li><a href="global.html#GpioCallback">GpioCallback</a></li><li><a href="global.html#GpioDelete">GpioDelete</a></li><li><a href="global.html#GpioGet">GpioGet</a></li><li><a href="global.html#GpioIsOpen">GpioIsOpen</a></li><li><a href="global.html#GpioIsValid">GpioIsValid</a></li><li><a href="global.html#GpioOpen">GpioOpen</a></li><li><a href="global.html#GpioSet">GpioSet</a></li><li><a href="global.html#MeshDeviceInfoRead">MeshDeviceInfoRead</a></li><li><a href="global.html#MeshDeviceInfoWrite">MeshDeviceInfoWrite</a></li><li><a href="global.html#MeshElementAdd">MeshElementAdd</a></li><li><a href="global.html#MeshLocalAddressRead">MeshLocalAddressRead</a></li><li><a href="global.html#MeshModelAddOpcode">MeshModelAddOpcode</a></li><li><a href="global.html#MeshModelCreate">MeshModelCreate</a></li><li><a href="global.html#MeshModelGenericCreate">MeshModelGenericCreate</a></li><li><a href="global.html#MeshNodeConfigRead">MeshNodeConfigRead</a></li><li><a href="global.html#MeshPublish">MeshPublish</a></li><li><a href="global.html#MeshReliablePublish">MeshReliablePublish</a></li><li><a href="global.html#MeshReply">MeshReply</a></li><li><a href="global.html#MeshSetBeaconUIDEventCallback">MeshSetBeaconUIDEventCallback</a></li><li><a href="global.html#MeshSetBeaconURLEventCallback">MeshSetBeaconURLEventCallback</a></li><li><a href="global.html#MeshSetDataEventCallback">MeshSetDataEventCallback</a></li><li><a href="global.html#MeshSetIBeaconEventCallback">MeshSetIBeaconEventCallback</a></li><li><a href="global.html#MeshSetReliableEventCallback">MeshSetReliableEventCallback</a></li><li><a href="global.html#MeshStatusReply">MeshStatusReply</a></li><li><a href="global.html#MeshVersionRead">MeshVersionRead</a></li><li><a href="global.html#MeshVersionWrite">MeshVersionWrite</a></li><li><a href="global.html#MiscAtExecute">MiscAtExecute</a></li><li><a href="global.html#StreamAsynchRead">StreamAsynchRead</a></li><li><a href="global.html#StreamConnect">StreamConnect</a></li><li><a href="global.html#StreamCreate">StreamCreate</a></li><li><a href="global.html#StreamDestroy">StreamDestroy</a></li><li><a href="global.html#StreamDisconnect">StreamDisconnect</a></li><li><a href="global.html#StreamGetAtId">StreamGetAtId</a></li><li><a href="global.html#StreamGetBtFrameSize">StreamGetBtFrameSize</a></li><li><a href="global.html#StreamGetDebugId">StreamGetDebugId</a></li><li><a href="global.html#StreamGetUartId">StreamGetUartId</a></li><li><a href="global.html#StreamGetUrl">StreamGetUrl</a></li><li><a href="global.html#StreamSend">StreamSend</a></li><li><a href="global.html#StreamStatus">StreamStatus</a></li><li><a href="global.html#SystemBleStart">SystemBleStart</a></li><li><a href="global.html#SystemDeepSleep">SystemDeepSleep</a></li><li><a href="global.html#SystemGetAvailHeap">SystemGetAvailHeap</a></li><li><a href="global.html#SystemGetRetentionValue">SystemGetRetentionValue</a></li><li><a href="global.html#SystemMeshStart">SystemMeshStart</a></li><li><a href="global.html#SystemSetRetentionValue">SystemSetRetentionValue</a></li><li><a href="global.html#SystemSetSysTickMode">SystemSetSysTickMode</a></li><li><a href="global.html#TimerStart">TimerStart</a></li><li><a href="global.html#TimerStartReoccurring">TimerStartReoccurring</a></li><li><a href="global.html#TimerStop">TimerStop</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.2</a> on Tue Jul 02 2019 12:56:15 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
